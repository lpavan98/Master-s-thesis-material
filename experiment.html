<!DOCTYPE html>
<html>
  <head>
    <title>Lorenzo's concept learning experiment</title>
    <script src="https://unpkg.com/jspsych@7.3.4"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-canvas-keyboard-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-survey@0.2.2"></script>
    <script src="https://unpkg.com/@jspsych/plugin-browser-check@1.0.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-fullscreen@1.2.1"></script>
    <script src="https://unpkg.com/@jspsych/plugin-call-function@1.1.3"></script>
    <link href="https://unpkg.com/jspsych@7.3.4/css/jspsych.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="https://unpkg.com/@jspsych/plugin-survey@0.2.2/css/survey.css">
  </head>
  <body></body>
  <script>

var jsPsych = initJsPsych({
  use_webaudio: false,
  on_finish: function(){
    console.log('The experiment is over, thank you for participating!');
  }
});

// The way shapes are defined (the code from here until line 63) was taken from the GitHub forum of jsPsych and slightly modified. The way stimuli are represented (stimulus_listener_1 to 4, which are defined from line 65), was also suggested on that forum. Lastly, the way in which the canvas is divided in two parts (left and right) to accommodate the current stimulus and the record of previous trials is based on suggestions from that forum: the end result greatly differs, but the basic structure is the same.
var SIZE = [20, 60, 100]; // Radius represents size
var COLOR = ['red', 'green', 'blue'];
var SHAPE = [
    function draw_circle(context, center_x, center_y, radius, color) {
        context.save();
        context.fillStyle = color;

        context.beginPath();
        context.arc(center_x, center_y, radius, 0, Math.PI * 2);
        context.closePath();
        
        context.fill();
        context.restore();
    },
    function draw_square(context, center_x, center_y, radius, color) {
        context.save();
        context.fillStyle = color;
        
        let len = radius * Math.sqrt(2);
        context.fillRect(center_x - len / 2, center_y - len / 2, len, len);

        context.restore();
    },
    function draw_triangle(context, center_x, center_y, radius, color) {
        context.save();
        context.fillStyle = color;

        context.moveTo(center_x, center_y - radius);
        context.beginPath();
        context.lineTo(center_x + radius / 2 * Math.sqrt(3), center_y + radius / 2);
        context.lineTo(center_x - radius / 2 * Math.sqrt(3), center_y + radius / 2);
        context.lineTo(center_x, center_y - radius);
        context.closePath();

        context.fill();
        context.restore();
    }
];

var stimulus_listener_1 = [
    { stim: ['213', '131', '322'], word: 'P', correct: 0, correct_response: '1'},
    { stim: ['121', '232', '323'], word: 'Q', correct: 0, correct_response: '1'},
    { stim: ['122', '232', '233'], word: 'Q', correct: 0, correct_response: '1'},
    { stim: ['223', '133', '332'], word: 'P', correct: 0, correct_response: '1'},
    { stim: ['133', '223', '332'], word: 'Q', correct: 0, correct_response: '1', pragmatics_wrong: '223'},
    { stim: ['223', '311', '312'], word: 'P', correct: 0, correct_response: '1'},
    { stim: ['133', '232', '323'], word: 'Q', correct: 0, correct_response: '1'},
    { stim: ['123', '222', '323'], word: 'Q', correct: 0, correct_response: '1'},
    { stim: ['123', '222', '323'], word: 'P', correct: 2, correct_response: '1', pragmatics_wrong: '123'},
    { stim: ['112', '231', '322'], word: 'Q', correct: 0, correct_response: '1'},
    { stim: ['233', '322', '311'], word: 'P', correct: 0, correct_response: '1'},
    { stim: ['323', '112', '232'], word: 'P', correct: 0, correct_response: '1'},
    { stim: ['333', '312', '321'], word: 'P', correct: 0, correct_response: '1'},
    { stim: ['333', '322', '311'], word: 'P', correct: 0, correct_response: '1'},
    { stim: ['333', '322', '311'], word: 'Q', correct: 2, correct_response: '1', pragmatics_wrong: '333'},
    { stim: ['213', '131', '112'], word: 'P', correct: 0, correct_response: '1'},
    { stim: ['212', '232', '222'], word: 'Q', correct: 0, correct_response: '1'},
    { stim: ['313', '333', '321'], word: 'Q', correct: 0, correct_response: '1'},
    { stim: ['213', '333', '221'], word: 'Q', correct: 0, correct_response: '1'},
    { stim: ['213', '333', '221'], word: 'P', correct: 1, correct_response: '1', pragmaticswrongh: '213'},
    { stim: ['211', '231', '322'], word: 'Q', correct: 0, correct_response: '1'},
    { stim: ['133', '131', '323'], word: 'P', correct: 2, correct_response: '1'},
];
var stimulus_listener_2 = [
    { stim: ['332', '221', '111'], word: 'P', correct: 1, correct_response: '2'},
    { stim: ['331', '221', '113'], word: 'P', correct: 1, correct_response: '2'},
    { stim: ['331', '312', '223'], word: 'Q', correct: 1, correct_response: '2'},
    { stim: ['133', '212', '233'], word: 'Q', correct: 1, correct_response: '2'},
    { stim: ['133', '212', '323'], word: 'Q', correct: 1, correct_response: '2'},
    { stim: ['133', '212', '323'], word: 'P', correct: 2, correct_response: '2', pragmatics_wrong: '212'},
    { stim: ['112', '323', '123'], word: 'Q', correct: 0, correct_response: '2'},
    { stim: ['131', '222', '323'], word: 'Q', correct: 1, correct_response: '2'},
    { stim: ['131', '122', '322'], word: 'Q', correct: 1, correct_response: '2'},
    { stim: ['131', '222', '322'], word: 'Q', correct: 1, correct_response: '2'},
    { stim: ['131', '222', '322'], word: 'P', correct: 2, correct_response: '2', pragmatics_wrong: '222'},
    { stim: ['113', '211', '122'], word: 'P', correct: 2, correct_response: '2'},
    { stim: ['123', '112', '313'], word: 'P', correct: 0, correct_response: '2'},
    { stim: ['131', '211', '322'], word: 'P', correct: 2, correct_response: '2'},
    { stim: ['131', '211', '322'], word: 'Q', correct: 1, correct_response: '2', pragmatics_wrong: '322'},
    { stim: ['122', '123', '131'], word: 'Q', correct: 0, correct_response: '2'},
    { stim: ['132', '223', '321'], word: 'P', correct: 1, correct_response: '2'},
    { stim: ['231', '321', '311'], word: 'P', correct: 1, correct_response: '2'},
    { stim: ['132', '223', '321'], word: 'P', correct: 1, correct_response: '2'},
    { stim: ['132', '223', '321'], word: 'Q', correct: 2, correct_response: '2', pragmatics_wrong: '223'},
    { stim: ['233', '121', '111'], word: 'P', correct: 1, correct_response: '2'},
    { stim: ['332', '313', '311'], word: 'Q', correct: 2, correct_response: '2'},
];
var stimulus_listener_3 = [
    { stim: ['232', '312', '322'], word: 'Q', correct: 1, correct_response: '3'},
    { stim: ['121', '111', '232'], word: 'P', correct: 2, correct_response: '3'},
    { stim: ['112', '121', '221'], word: 'Q', correct: 0, correct_response: '3'},
    { stim: ['112', '121', '221'], word: 'Q', correct: 0, correct_response: '3'},
    { stim: ['112', '121', '221'], word: 'P', correct: 2, correct_response: '3', pragmatics_wrong: '112'},
    { stim: ['212', '222', '232'], word: 'Q', correct: 0, correct_response: '3'},
    { stim: ['133', '132', '231'], word: 'P', correct: 2, correct_response: '3'},
    { stim: ['211', '113', '133'], word: 'P', correct: 0, correct_response: '3'},
    { stim: ['211', '113', '133'], word: 'Q', correct: 1, correct_response: '3', pragmatics_wrong: '211'},
    { stim: ['321', '213', '131'], word: 'Q', correct: 1, correct_response: '3'},
    { stim: ['311', '112', '131'], word: 'Q', correct: 1, correct_response: '3'},
    { stim: ['311', '112', '131'], word: 'P', correct: 0, correct_response: '3'},
    { stim: ['132', '133', '333'], word: 'P', correct: 2, correct_response: '3'},
    { stim: ['313', '112', '133'], word: 'P', correct: 0, correct_response: '3'},
    { stim: ['112', '312', '113'], word: 'P', correct: 1, correct_response: '3'},
    { stim: ['111', '221', '313'], word: 'Q', correct: 2, correct_response: '3'},
    { stim: ['111', '221', '313'], word: 'P', correct: 1, correct_response: '3', pragmaticswrongh: '313'},
    { stim: ['323', '231', '212'], word: 'Q', correct: 2, correct_response: '3'},
    { stim: ['122', '233', '133'], word: 'P', correct: 1, correct_response: '3'},
    { stim: ['312', '333', '121'], word: 'Q', correct: 0, correct_response: '3'},
    { stim: ['312', '333', '121'], word: 'P', correct: 1, correct_response: '3', pragmaticswrongh: '312'},
    { stim: ['311', '111', '213'], word: 'Q', correct: 2, correct_response: '3'},
];
var stimulus_listener_4 = [
    { stim: ['311', '331', '123'], word: 'P', correct: 0, correct_response: '4'},
    { stim: ['321', '221', '113'], word: 'Q', correct: 0, correct_response: '4'},
    { stim: ['111', '312', '212'], word: 'Q', correct: 1, correct_response: '4'},
    { stim: ['111', '212', '312'], word: 'Q', correct: 2, correct_response: '4'},
    { stim: ['111', '212', '312'], word: 'P', correct: 0, correct_response: '4', pragmatics_wrong: '312'},
    { stim: ['212', '213', '211'], word: 'P', correct: 2, correct_response: '4'},
    { stim: ['231', '131', '311'], word: 'P', correct: 2, correct_response: '4'},
    { stim: ['221', '131', '211'], word: 'P', correct: 2, correct_response: '4'},
    { stim: ['221', '131', '211'], word: 'Q', correct: 1, correct_response: '4', pragmatics_wrong: '211'},
    { stim: ['333', '121', '212'], word: 'Q', correct: 0, correct_response: '4'},
    { stim: ['311', '223', '112'], word: 'Q', correct: 0, correct_response: '4'},
    { stim: ['223', '232', '111'], word: 'P', correct: 2, correct_response: '4'},
    { stim: ['223', '232', '111'], word: 'Q', correct: 1, correct_response: '4', pragmatics_wrong: '111'},
    { stim: ['312', '131', '211'], word: 'P', correct: 2, correct_response: '4'},
    { stim: ['313', '123', '211'], word: 'P', correct: 2, correct_response: '4'},
    { stim: ['313', '221', '222'], word: 'Q', correct: 0, correct_response: '4'},
    { stim: ['213', '122', '231'], word: 'Q', correct: 2, correct_response: '4'},
    { stim: ['311', '333', '222'], word: 'P', correct: 0, correct_response: '4'},
    { stim: ['311', '333', '222'], word: 'P', correct: 0, correct_response: '4'},
    { stim: ['311', '333', '222'], word: 'Q', correct: 1, correct_response: '4', pragmaticswrongh: '311'},
    { stim: ['123', '111', '133'], word: 'Q', correct: 2, correct_response: '4'},
    { stim: ['132', '323', '111'], word: 'P', correct: 2, correct_response: '4'},
];
var stimulus_speaker = [
    { stim: ['223', '131', '312'], pointed: 1, correct_response: 'p'},
    { stim: ['222', '232', '221'], pointed: 1, correct_response: 'p'},
    { stim: ['131', '233', '321'], pointed: 2, correct_response: 'q'},
    { stim: ['112', '232', '333'], pointed: 1, correct_response: 'p'},
    { stim: ['322', '123', '111'], pointed: 0, correct_response: 'q'},
    { stim: ['322', '123', '111'], pointed: 0, correct_response: 'q'},
    { stim: ['212', '121', '333'], pointed: 2, correct_response: 'q'},
    { stim: ['322', '133', '121'], pointed: 0, correct_response: 'q'},
    { stim: ['121', '132', '322'], pointed: 1, correct_response: 'p'},
    { stim: ['213', '132', '313'], pointed: 2, correct_response: 'q'},
    { stim: ['221', '113', '231'], pointed: 2, correct_response: 'p'},
    { stim: ['131', '233', '321'], pointed: 0, correct_response: 'p'},
    { stim: ['231', '232', '212'], pointed: 0, correct_response: 'q'},
    { stim: ['112', '223', '311'], pointed: 2, correct_response: 'q'},
    { stim: ['111', '123', '131'], pointed: 2, correct_response: 'p'},
    { stim: ['221', '323', '212'], pointed: 1, correct_response: 'q'},
    { stim: ['333', '231', '212'], pointed: 0, correct_response: 'q'},
    { stim: ['231', '333', '212'], pointed: 0, correct_response: 'p'},
    { stim: ['132', '133', '213'], pointed: 0, correct_response: 'p'},
    { stim: ['131', '211', '112'], pointed: 0, correct_response: 'p'},
    { stim: ['113', '232', '321'], pointed: 2, correct_response: 'q'},
    { stim: ['133', '313', '132'], pointed: 2, correct_response: 'p'},

];
const stimulus_length = 22;

// Initialize global variables
var trial_id = 0;
var record = [];
var index = [0,1,2];
var current_stimulus = -1;
var block_order = jsPsych.randomization.shuffle([stimulus_listener_1, stimulus_listener_2, stimulus_listener_3, stimulus_listener_4]);
var block_order_number = [block_order[0][0].correct_response, block_order[1][0].correct_response, block_order[2][0].correct_response, block_order[3][0].correct_response];

function return_stimulus(x) {
    return block_order[x];
}

// Only used for control blocks, given array and capital P or Q, returns array with only lines where there is that word
function filterByWord(array, word) {
    return array.filter(item => item.word === word);
}
// Randomize order of appearance of the three items for the listener blocks
function random_stimuli_line_order(stimolo) {
    // Get correct element from its index, called "correct". Then shuffle the 3 items. Lastly, get the correct index, given the correct element
    let correct_element = stimolo.stim[stimolo.correct];
    stimolo.stim = jsPsych.randomization.shuffle(stimolo.stim);
    stimolo.correct = stimolo.stim.indexOf(correct_element);
    // Get correct response letter, given the index of the correct element
    if (stimolo.correct == 0) {
        stimolo.correct_response = 'j';
    } else if (stimolo.correct == 1) {
        stimolo.correct_response = 'k';
    } else {
        stimolo.correct_response = 'l';
    }
}

function pragmatic_wrong_finder(stimolo) {
    if ("pragmatics_wrong" in stimolo) {
        if (stimolo.stim.indexOf(stimolo.pragmatics_wrong) == 0) {
            return('j');
        } else if (stimolo.stim.indexOf(stimolo.pragmatics_wrong) == 1) {
            return('k');
        } else {
            return('l');
        }
    } else {
        return("-");
    }
}
function pragmatic_wrong_finder_h(stimolo) {
    if ("pragmaticswrongh" in stimolo) {
        if (stimolo.stim.indexOf(stimolo.pragmaticswrongh) == 0) {
            return('j');
        } else if (stimolo.stim.indexOf(stimolo.pragmaticswrongh) == 1) {
            return('k');
        } else {
            return('l');
        }
    } else {
        return("-");
    }
}

// Draw previous trials in the right part of the screen
function draw_right(context, record, mos = 'main', condition = 'speaker') {
    // Explain what the record in the right part of the screen is
    context.font = "14pt Arial";
    if (condition == 'speaker') {
        if (mos == 'main') {
            if (trial_id > 0) {
                context.fillText("Record of previous trials, with the answers you gave.", 820, 40);
            }
        } else {
            context.fillText("Record of previous trials, with the answers you gave.", 820, 40);
        }
    } else {
        if (mos == 'main') {
            if (trial_id > 0) {
                context.fillText("Record of previous trials. The right answer is underlined.", 820, 40);
            }
        } else {
            context.fillText("Record of previous trials. The right answer is underlined.", 820, 40);
        }
    }

    context.font = "20pt Arial";
    // In experimental block, mos is main. In blocks that just show last record, mos is show.
    let main_or_show = record.length - 1;
    if (mos == 'show') {
        main_or_show = record.length;
    }
    for (let i = 0; i < main_or_show; i++) {
        let entry = record[i];
        for (let j = 0; j < 3; j++) {
            let s = entry[j];
            let size = s[0] / 4;
            let color = s[1];
            let draw_func = s[2];
            // The entries in the record are longer for the listener. Therefore, indexes in the arrays s differ between speaker and listener. Also adjust the stimuli on the middle for the LOT listener
            let x = 0;
            let x_shift = 0;
            correct_print = jsPsych.data.get().filter({task: 'speaker'}).select('response').values[i];
            if (condition != 'speaker') {
                x = 1;
                correct_print = s[3];
                if (condition == 'LOT_listener') {
                    x_shift = 150;
                }
            }
            // Draw leftmost column 
            if (i < (stimulus_length / 2)) {
                draw_func(context, j * 50 + 850 + x_shift, i * 60 + 75, size, color);
                // Display message of interest unless we are in the control group
                if (condition != 'LOT_listener') {
                    context.fillText(correct_print, 1000 + x_shift, i * 60 + 85);
                }
                // Underline correct answer
                if (s[3 + x] == 0) {
                    context.fillText("__", 836 + x_shift, i * 60 + 97)
                } else if (s[3 + x] == 1) {
                    context.fillText("__", 836 + x_shift + 50, i * 60 + 97)
                } else {
                    context.fillText("__", 836 + x_shift + 100, i * 60 + 97)
                } 
            // Draw rightmost column                 
            } else {
                draw_func(context, j * 50 + 1100, (i - (stimulus_length / 2)) * 60 + 75, size, color);
                context.fillText(correct_print, 1250, (i - (stimulus_length / 2)) * 60 + 85);
                // Underline correct answer
                if (s[3 + x] == 0) {
                    context.fillText("__", 836 + 250, (i - (stimulus_length / 2)) * 60 + 97)
                } else if (s[3 + x] == 1) {
                    context.fillText("__", 836 + 50 + 250, (i - (stimulus_length / 2)) * 60 + 97)
                } else {
                    context.fillText("__", 836 + 100 + 250, (i - (stimulus_length / 2)) * 60 + 97)
                }
            }
        }
    }
}

// Auxiliary function for labeling_data.
// "cr" stays for "control right", "cw" for "control wrong", "cer" for "control equal right", "cew" for "control equal wrong", "pr" for "pragmatics right", "phr" for "pragmatics hard right".
function labeling(pragmatics_or_control, correctness) {
    if (pragmatics_or_control == "control") {
        if (correctness) {
            return("cr");
        } else {
            return("cw");
        }
    } else if (pragmatics_or_control == "pragmatics") {
        if (correctness) {
            return("pr");
        } else {
            return("-");
        }
    } else if (pragmatics_or_control == "equal_contr") {
        if (correctness) {
            return("cer");
        } else {
            return("cew");
        }
    } else {
        if (correctness) {
            return("phr");
        } else {
            return("-");
        }
    }
}

// Label data: store correctness values of pragmatic trials with repetitions and control trials.
// OR (||) short-circuits as soon as it finds the first true condition, unlike the includes operator on arrays, therefore || is used here.
function labeling_data(mixed_or_control, block, correctness, trial_number, p_or_q) {
    // Mixed listener task, i.e. group using pragmatic reasoning
    if (mixed_or_control == "mixed") {
        if (block == 1) {
            if (trial_number == 5 || trial_number == 6 || trial_number == 11 || trial_number == 13 || trial_number == 15 || trial_number == 21) {
                return(labeling("control", correctness));
            } else if (trial_number == 4 || trial_number == 8 || trial_number == 14) {
                return(labeling("pragmatics", correctness));
            } else if (trial_number == 19) {
                return(labeling("prag_hard", correctness));
            }
        } else if (block == 2) {
            if (trial_number == 1 || trial_number == 4 || trial_number == 9 || trial_number == 13 || trial_number == 15) {
                return(labeling("control", correctness));
            } else if (trial_number == 5 || trial_number == 10 || trial_number == 14 || trial_number == 19) {
                return(labeling("pragmatics", correctness));
            } else if (trial_number == 18) {
                return(labeling("equal_contr", correctness));
            }
        } else if (block == 3) {
            if (trial_number == 10 || trial_number == 17 || trial_number == 19 || trial_number == 21) {
                return(labeling("control", correctness));
            } else if (trial_number == 3) {
                return(labeling("equal_contr", correctness));
            } else if (trial_number == 4 || trial_number == 8) {
                return(labeling("pragmatics", correctness));
            } else if (trial_number == 16 || trial_number == 20) {
                return(labeling("prag_hard", correctness));
            }
        } else if (block == 4) {
            if (trial_number == 6 || trial_number == 7 || trial_number == 11 || trial_number == 13 || trial_number == 14 || trial_number == 17 || trial_number == 21) {
                return(labeling("control", correctness));
            } else if(trial_number == 3 || trial_number == 18) {
                return(labeling("equal_contr", correctness));
            } else if (trial_number == 4 || trial_number == 8 || trial_number == 12) {
                return(labeling("pragmatics", correctness));
            } else if (trial_number == 19) {
                return(labeling("prag_hard", correctness));
            }
        }
    // Control (LOT only) group
    } else {
        if (block == 1) {
            if (p_or_q == "P") {
                if (trial_number == 2 || trial_number == 5 || trial_number == 7 || trial_number == 8 || trial_number == 10) {
                    return(labeling("control", correctness));
                }
            } else {
                if (trial_number == 3) {
                    return(labeling("control", correctness));
                }
            }
        } else if (block == 2) {
            if (p_or_q == "P") {
                if (trial_number == 1 || trial_number == 6) {
                    return(labeling("control", correctness));
                } else if (trial_number == 9) {
                    return(labeling("equal_contr", correctness));
                }
            } else {
                if (trial_number == 2 || trial_number == 6 || trial_number == 8) {
                    return(labeling("control", correctness));
                }
            }
        } else if (block == 3) {
            if (p_or_q == "Q") {
                if (trial_number == 6 || trial_number == 8 || trial_number == 9 || trial_number == 10) {
                    return(labeling("control", correctness));
                } else if (trial_number == 2) {
                    return(labeling("equal_contr", correctness));
                }
            }
        } else if (block == 4) {
            if (p_or_q == "P") {
                if (trial_number == 3 || trial_number == 4 || trial_number == 5 || trial_number == 6 || trial_number == 7 || trial_number == 8 || trial_number == 10) {
                    return(labeling("control", correctness));
                } else if (trial_number == 9) {
                    return(labeling("equal_contr", correctness));
                }
            } else {
                if (trial_number == 2) {
                    return(labeling("equal_contr", correctness));
                }
            }
        }
    }
}

// In the original version of the index ([0,1,2]), size is represented as 0, color as 1, shape as 2. This will be the same in the randomized index array. The figures originated will differ after the randomization of the index, as the position that once represented the critical feature in the original array, may now be used for another feature. Therefore, when we first had P that stayed for a color, now it can stay for a shape, if the second position of the array is 2 instead of 1 after the randomization.
// If we have that P was "red" before the randomization (written as x1x), we first need to clarify what the new feature of interest is (it was color before the randomization), as described above. Since red is the first color (we had x1x as P), it is sufficient to get feature_of_interest[1].
function find_right_concept(concept_of_interest) {
    if (concept_of_interest == "P") {
        if (block_order_number[current_stimulus] == 1) {
            // In the non-randomized version, P is 'triangle and (not size 1)
            if (index[2] == 0) {
                if (index[0] == 2) {
                    return(String(SIZE[2]) + "_and_not_" + SHAPE[0].name);
                } else if (index[0] == 1) {
                    return(String(SIZE[2]) + "_and_not_" + COLOR[0]);
                }
            } else if (index[2] == 1) {
                if (index[0] == 0) {
                    return(COLOR[2] + "_and_not_" + String(SIZE[0]));
                } else if (index[0] == 2) {
                    return(COLOR[2] + "_and_not_" + SHAPE[0].name);
                }
            } else {
                if (index[0] == 0) {
                    return(SHAPE[2].name + "_and_not_" + String(SIZE[0]));
                } else if (index[0] == 1) {
                    return(SHAPE[2].name + "_and_not_" + COLOR[0]);
                }
            }
        } else if (block_order_number[current_stimulus] == 2) {
            // In the non-randomized version, P is 'green'
            if (index[1] == 0) {
                return(String(SIZE[1]));
            } else if (index[1] == 1) {
                return(COLOR[1]);
            } else {
                return(SHAPE[1].name);
            }
        } else if (block_order_number[current_stimulus] == 3) {
            // In the non-randomized version, P is "not size 1"
            if (index[0] == 0) {
                return("not_" + String(SIZE[0]));
            } else if (index[0] == 1) {
                return("not_" + COLOR[0]);
            } else {
                return("not_" + SHAPE[0].name);
            }
        } else {
            // In the non-randomized version, P is "circle and red"
            if (index[2] == 0) {
                if (index[1] == 2) {
                    return(String(SIZE[0]) + "_and_" + SHAPE[0].name);
                } else if (index[1] == 1) {
                    return(String(SIZE[0]) + "_and_" + COLOR[0]);
                }
            } else if (index[2] == 1) {
                if (index[1] == 0) {
                    return(COLOR[0] + "_and_" + String(SIZE[0]));
                } else if (index[1] == 2) {
                    return(COLOR[0] + "_and_" + SHAPE[0].name);
                }
            } else {
                if (index[1] == 0) {
                    return(SHAPE[0].name + "_and_" + String(SIZE[0]));
                } else if (index[1] == 1) {
                    return(SHAPE[0].name + "_and_" + COLOR[0]);
                }
            }
        }
    } else {
        if (block_order_number[current_stimulus] == 1) {
            // In the non-randomized version, Q is 'red or size 1'
            if (index[1] == 0) {
                if (index[0] == 2) {
                    return(String(SIZE[0]) + "_or_" + SHAPE[0].name);
                } else if (index[0] == 1) {
                    return(String(SIZE[0]) + "_or_" + COLOR[0]);
                }
            } else if (index[1] == 1) {
                if (index[0] == 0) {
                    return(COLOR[0] + "_or_" + String(SIZE[0]));
                } else if (index[0] == 2) {
                    return(COLOR[0] + "_or_" + SHAPE[0].name);
                }
            } else {
                if (index[0] == 0) {
                    return(SHAPE[0].name + "_or_" + String(SIZE[0]));
                } else if (index[0] == 1) {
                    return(SHAPE[0].name + "_or_" + COLOR[0]);
                }
            }
        } else if (block_order_number[current_stimulus] == 2) {
            // In the non-randomized version, Q is "not(blue or triangle)"
            if (index[1] == 0) {
                if (index[2] == 2) {
                    return("not_(" + String(SIZE[2]) + "_or_" + SHAPE[2].name + ")");
                } else if (index[2] == 1) {
                    return("not_(" + String(SIZE[2]) + "_or_" + COLOR[2] + ")");
                }
            } else if (index[1] == 1) {
                if (index[2] == 0) {
                    return("not_(" + COLOR[2] + "_or_" + String(SIZE[2]) + ")");
                } else if (index[2] == 2) {
                    return("not_(" + COLOR[2] + "_or_" + SHAPE[2].name + ")");
                }
            } else {
                if (index[2] == 0) {
                    return("not_(" + SHAPE[2].name + "_or_" + String(SIZE[2]) + ")");
                } else if (index[2] == 1) {
                    return("not_(" + SHAPE[2].name + "_or_" + COLOR[2] + ")");
                }
            }
        } else if (block_order_number[current_stimulus] == 3) {
            // In the non-randomized version, Q is "red and (not circles)"
            if (index[1] == 0) {
                if (index[2] == 2) {
                    return(String(SIZE[0]) + "_and_(" + SHAPE[1].name + "_or_" + SHAPE[2].name + ")");
                } else if (index[2] == 1) {
                    return(String(SIZE[0]) + "_and_(" + COLOR[1] + "_or_" + COLOR[2] + ")");
                }
            } else if (index[1] == 1) {
                if (index[2] == 0) {
                    return(COLOR[0] + "_and_(" + String(SIZE[1]) + "_or_" + String(SIZE[2]) + ")");
                } else if (index[2] == 2) {
                    return(COLOR[0] + "_and_(" + SHAPE[1].name + "_or_" + SHAPE[2].name + ")");
                }
            } else {
                if (index[2] == 0) {
                    return(SHAPE[0].name + "_and_(" + String(SIZE[1]) + "_or_" + String(SIZE[2]) + ")");
                } else if (index[2] == 1) {
                    return(SHAPE[0].name + "_and_(" + COLOR[1] + "_or_" + COLOR[2] + ")");
                }
            }
        } else {
            // In the non-randomized version, Q is 'size 3 or blue'
            if (index[0] == 0) {
                if (index[1] == 2) {
                    return(String(SIZE[2]) + "_or_" + SHAPE[2].name);
                } else if (index[1] == 1) {
                    return(String(SIZE[2]) + "_or_" + COLOR[2]);
                }
            } else if (index[0] == 1) {
                if (index[1] == 0) {
                    return(COLOR[2] + "_or_" + String(SIZE[2]));
                } else if (index[1] == 2) {
                    return(COLOR[2] + "_or_" + SHAPE[2].name);
                }
            } else {
                if (index[1] == 0) {
                    return(SHAPE[2].name + "_or_" + String(SIZE[2]));
                } else if (index[1] == 1) {
                    return(SHAPE[2].name + "_or_" + COLOR[2]);
                }
            }
        }
    }
}

var enter_fullscreen = {
  type: jsPsychFullscreen,
  fullscreen_mode: true
}

var welcome = {type: jsPsychSurvey,
    pages: [
        [
            {
                type: 'html',
                prompt: `<h2>Important information on the study</h2>
                        <p>You are welcome to participate in this online questionnaire. The experiment is part of a study that investigates how people learn new concepts. Please, notice that you need to have a physical keyboard in order to participate.<p>

                        <p>The study will take you around 40 minutes to complete. Please, make sure that you will not be distracted for the duration of the study: switch off messaging systems, your phone, background music etc.</p>`,
            },
            {   
                type: 'multi-select',
                prompt: 'The use of colors throughout the study leads to the need of an extra step in the data analysis of colorblind participants. Therefore, it would be important for us to know if you are colorblind.',
                name:'color_blind',
                options: ['By ticking this box, you communicate to us that you are colorblind.'], 
                required: false,
            },
            {
                        type: 'html',
                        prompt: `<h3>Data protection information</h3>
                        <p>Your participation is voluntary. We will only collect your responses if you provide your consent below. Your Prolific ID will be deleted from our data once your submission has been approved by the researchers. The data will then be stored anonymously, with no personally identifiable information, on a server owned by Utrecht University. The anonymized data will be stored for at least 10 years. All collected data will be used for research purpose only.</p>

                        <p>If you wish to withdraw from completing the questionnaire, you may do so at any moment without further explanation. Your answers up to that moment will not be stored. Please note that in case you decide to withdraw from completing the questionnaire, you will not be payed for this experiment.</p>

                        <h3>Contact information</h3>
                        <p>In case you experience any problems, want to give feedback or have any questions, you are welcome to email the experiment designer at <a href="mailto:l.pavan@students.uu.nl">l.pavan@students.uu.nl</a></p>`, 
            },
            {
                type: 'multi-choice',
                prompt: '',
                options: ['I have read and understood the information provided above and I declare that I voluntarily participate in this research.'],
                name: 'Tick the following box and then click on "continue" to participate', 
                required: true,
            }
        ],
        [
            {
                type: 'text',
                prompt: "Please, write fill a unique identifier of your choice (for example, a short sentence).", 
                name: 'Identifier',
                required: true,
            }
        ],
        [
            {
                type: 'html',
                prompt:  `<h2>General instructions</h2>
                <p>The focus of this study is to learn words in an alien language. The study involves communication among participants. You can either be given the meaning of two words and asked to help other participants discover the meaning of those words, or you can be unaware of the meaning of two words and be asked to figure out their meanings with the help of another participant.</p>

                <p>The communication among participants is asynchronous: when sending messages to another participant, an entire block of messages will be sent at once. Then, another participant whose task is to be on the receiving side will use that block of messages to learn.</p>

                <p>Each alien word is going to be associated to a key on the keyboard. The keys that we are using from now on to represent the two words are <em>p</em> and <em>q</em>.</p>`
            }
        ]

    ],
    button_label_next: 'Continue',
    button_label_back: 'Previous',
    button_label_finish: 'Click here to be assigned your first task. You will not be allowed to go back anymore',
    required_question_label: "",
        
};

var refuse_mobile_users = {
  type: jsPsychBrowserCheck,
  features: ["mobile"],
  inclusion_function: (data) => {
    return data.mobile === false
  },
  exclusion_message: (data) => {
    if(data.mobile){
      return '<p>You must use a desktop/laptop computer to participate in this experiment.</p>';
    }
  }
};

var instructions_speaker = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: 
        '<h3>Task 1 of 5</h3><p>Your next task is to help another participant learn the meaning of two concepts that will be associated with <em>p</em> and <em>q</em>. The meaning of such concepts will be made clear to you. You will in fact see a description of each concept on top of the screen.</p><p>During the experiment, you will be shown three objects. The same three objects will be shown to another participant, who, unlike you, will need to learn the meaning of the words associated with <em>p</em> and <em>q</em>. One of the three objects will be underlined for you, but not for the other participant. You need to communicate either <em>p</em> or <em>q</em> to the other participant. Your goal is to make sure that that participant picks the underlined objects among the three displayed ones.</p><p>Being unaware of the meaning of <em>p</em> and <em>q</em>, the other participant will likely not be able to pick the right object in the first trials. However, both of you will be shown many sets containing three objects. In time, the other participant can thus learn the meaning of the words associated with <em>p</em> and <em>q</em> and become more accurate in returning the object which you wanted to be returned (the one underlined for you).</p><p>During the whole task, please take your time and send the message that you think is best to send in each situation. On the right part of the screen, you will see the record of trials you completed.</p><p>We suggest to keep a finger of the right hand on the <em>p</em> key and a finger of the left hand on the <em>q</em> key (ideally the index fingers).</p>',
    choices: ['p', 'q'],
    prompt: "<p>Press <em>p</em> or <em>q</em> to begin</p>"
};

var instructions_listener_mixed = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: function() {
        return `<h3>Task ${current_stimulus + 2} of 5</h3><p>In the next task, you will learn the meaning of two concepts, which will be associated with <em>p</em> and <em>q</em>. During the experiment, you will be shown sets of three objects. The same sets of three objects were shown to another participant, in the same order in which they will be shown to you. That participant was informed about the meaning of the words associated with <em>p</em> and <em>q</em>, unlike you. That participant sent you a message (either <em>p</em> or <em>q</em>) for each set of objects. Such messages will appear next to each set of objects. The aim of the participant who sent the messages to you is to have you pick a certain object out of the three displayed ones, for each set of objects. Your task is in fact not only to learn the meaning of the two concepts, but also to select the object that the other participant wanted you to return.</p><p>Of course, in the first couple of trials you will have no idea about the meaning of the concepts in question. That should however change later on. As a help, you will see the record of the trials that you already completed on the right part of the screen. This means that you will see all sets of three objects that were shown to you before, with the one that you were supposed to pick underlined, together with the message sent by the other participant. There is no time limit to complete the task, so please focus on being as accurate as possible in returning the object that the other participant wanted you to return, and look at the right part of the screen for help in solving the task.</p><p> We suggest to keep three fingers on the <em>j</em>, <em>k</em> and <em>l</em> keys, which are the keys that you will need to use to indicate which object you select.</p>`
    },
    choices: ['j', 'k', 'l'],
    prompt: "<p>Press <em>j</em>, <em>k</em> or <em>l</em> to begin</p>"
};

var instructions_listener_LOT_only = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: function() {
        return `<h3>Task ${current_stimulus + 2} of 5</h3><p>In the next task, you will learn the meaning of two concepts, which will be associated with <em>p</em> and <em>q</em>. During the experiment, you will be shown sets of three objects. The same sets of three objects were shown to another participant. That participant was informed about the meaning of the words associated with <em>p</em> and <em>q</em>, unlike you. That participant sent you a message (either <em>p</em> or <em>q</em>) for each set of objects. You will first see all objects associated a message and then all objects associated with the other one. The aim of the participant who sent the messages to you is to have you pick a certain object out of the three displayed ones, for each set of objects. Your task is in fact not only to learn the meaning of the two concepts, but also to select the object that the other participant wanted you to return.</p><p>Of course, in the first couple of trials you will have no idea about the meaning of the concepts in question. That should however change later on. As a help, you will see the record of the trials that you already completed on the right part of the screen. This means that you will see all sets of three objects that were shown to you before, with the one that you were supposed to pick underlined. There is no time limit to complete the task, so please focus on being as accurate as possible in returning the object that the other participant wanted you to return, and look at the right part of the screen for help in solving the task.</p><p> We suggest to keep three fingers on the <em>j</em>, <em>k</em> and <em>l</em> keys, which are the keys that you will need to use to indicate which object you select.</p>`
    },
    choices: ['j', 'k', 'l'],
    prompt: "<p>Press <em>j</em>, <em>k</em> or <em>l</em> to begin</p>"
};

let block_speaker = {
    type: jsPsychCanvasKeyboardResponse,
    stimulus: (canvas) => {
        let context = canvas.getContext('2d');

        context.font = "14pt Arial";
        context.fillText('P: blue objects but not triangles', 0, 50);
        context.fillText('Q: big objects', 0, 75);
        context.fillText('Press p or q. Your message will be shown to a participant who will learn the concepts.', 20, 160);
        context.fillText('Make the choice which will lead that participant to return the item that you see underlined.', 10, 180);

        let record_entry = [];

        // Randomize order of appearance
        var pointed_element = (stimulus_speaker[trial_id]).stim[(stimulus_speaker[trial_id]).pointed];
        stimulus_speaker[trial_id].stim = jsPsych.randomization.shuffle(stimulus_speaker[trial_id].stim);
        stimulus_speaker[trial_id].pointed = (stimulus_speaker[trial_id].stim).indexOf(pointed_element);

        // Draw current trial
        for (let i = 0; i < 3; i++) {
            let size = SIZE[stimulus_speaker[trial_id].stim[i][index[0]] - 1];
            let color = COLOR[stimulus_speaker[trial_id].stim[i][index[1]] - 1];
            let draw_func = SHAPE[stimulus_speaker[trial_id].stim[i][index[2]] - 1];
            draw_func(context, i * 200 + 200, 350, size, color);

            record_entry.push([size, color, draw_func, stimulus_speaker[trial_id].pointed]);
        }
        record.push(record_entry);

        // Underline pointed figure
        context.beginPath();
        if (stimulus_speaker[trial_id].pointed == 0) {
            context.moveTo(150, 470);
            context.lineTo(250, 470);
        } else if (stimulus_speaker[trial_id].pointed == 1) {
            context.moveTo(350, 470);
            context.lineTo(450, 470);
        } else {
            context.moveTo(550, 470);
            context.lineTo(650, 470);
        }
        context.stroke();
        context.closePath()

        // Draw the right part: previous trials
        draw_right(context, record);
    },
    canvas_size: [800, 1300],
    choices: ['q', 'p'],
    data: {
        task: 'speaker',
        correct_response: 'placeholder',
        correct: 'placeholder',
    },
    on_finish: function(data){
        jsPsych.data.get().addToLast({correct_response: stimulus_speaker[trial_id].correct_response});
        jsPsych.data.get().addToLast({correct: jsPsych.pluginAPI.compareKeys(data.response, data.correct_response)});
    }
}

// Look at complete record of previous trials: speaker version
let show_end_speaker = {
    type: jsPsychCanvasKeyboardResponse,
    stimulus: (canvas) => {
        let context = canvas.getContext('2d');
        context.font = "14pt Arial";
        context.fillText('P: blue objects but not triangles', 0, 50);
        context.fillText('Q: big objects', 0, 75);
        context.font = "20pt Arial";
        context.fillText('You have reached the end of this task.', 100, 320);
        context.fillText('    Press the space bar to continue.', 100, 355);
        draw_right(context, record, mos = 'show');
    },
    canvas_size: [800, 1300],
    choices: [' ']
}

let block_listener_mixed = {
    type: jsPsychCanvasKeyboardResponse,
    stimulus: (canvas) => {
        // Get the stimulus for this block from the block_order array, which is randomized when everything is loaded
        let stimolo = return_stimulus(current_stimulus)[trial_id];
        // Randomize order of appearance of the three items
        random_stimuli_line_order(stimolo);

        let context = canvas.getContext('2d');
        let record_entry = [];

        // Draw the left part: current trial
        context.font = "14pt Arial";
        context.fillText("Select the object which you think the other participant wanted you to pick,", 40, 40);
        context.fillText("given the message that you see on the right of the figures, which was sent", 40, 60);
        context.fillText("by that participant. Press j to select the leftmost object, k to select the", 40, 80);
        context.fillText("object displayed in the middle and l to select the rightmost object.", 40, 100);
        for (let i = 0; i < 3; i++) {
            let size = SIZE[stimolo.stim[i][index[0]] - 1];
            let color = COLOR[stimolo.stim[i][index[1]] - 1];
            let draw_func = SHAPE[stimolo.stim[i][index[2]] - 1];
            draw_func(context, i * 200 + 100, 300, size, color);

            record_entry.push([size, color, draw_func, stimolo.word, stimolo.correct]);
        }
        record.push(record_entry);

        context.font = "60pt Arial";
        context.fillText(stimolo.word, 650, 325);

        // Draw the right part: previous trials
        draw_right(context, record, mos = 'main', condition = 'listener');
    },
    canvas_size: [800, 1300],
    choices: ['j', 'k', 'l'],
    data: {
        task: 'listener',
    },
    on_finish: function(data){
        // Cannot add together correct_response and correct, because correct_response needs to be there in order for correct to be added
        jsPsych.data.get().addToLast({correct_response: (return_stimulus(current_stimulus))[trial_id].correct_response});
        jsPsych.data.get().addToLast({correct: jsPsych.pluginAPI.compareKeys(data.response, data.correct_response)});
        jsPsych.data.get().addToLast({randomization: [index, SHAPE[0].name, SHAPE[1].name, SHAPE[2].name, COLOR, SIZE]});
        jsPsych.data.get().addToLast({block_number: block_order_number[current_stimulus]});
        jsPsych.data.get().addToLast({label: labeling_data(mixed_or_control = "mixed", block = data.block_number, correctness = data.correct, trial_number = trial_id, p_or_q = "not_applicable")});
        jsPsych.data.get().addToLast({pw_label: jsPsych.pluginAPI.compareKeys(pragmatic_wrong_finder(return_stimulus(current_stimulus)[trial_id]), data.response)});
        jsPsych.data.get().addToLast({pwh_label: jsPsych.pluginAPI.compareKeys(pragmatic_wrong_finder_h(return_stimulus(current_stimulus)[trial_id]), data.response)});
    }
}

let block_listener_LOT_only = {
    type: jsPsychCanvasKeyboardResponse,
    stimulus: (canvas) => {
        // Get the stimulus for this block from the block_order array, which is randomized when everything is loaded, then filter the array based on the letter currently in use
        let stimolo = filterByWord(return_stimulus(current_stimulus), jsPsych.timelineVariable('letter'))[trial_id];
        // Randomize order of appearence of the three items
        random_stimuli_line_order(stimolo);

        let context = canvas.getContext('2d');
        let record_entry = [];

        // Draw the left part: current trial
        context.font = "14pt Arial";
        context.fillText("Select the object which you think the other participant wanted you to pick,", 40, 40);
        context.fillText(`given that that participant sent ${jsPsych.timelineVariable('letter')} as message. Press j to select the leftmost`, 40, 60);
        context.fillText("object, k for the object displayed in the middle and l for the rightmost object.", 40, 80);
        for (let i = 0; i < 3; i++) {
            let size = SIZE[stimolo.stim[i][index[0]] - 1];
            let color = COLOR[stimolo.stim[i][index[1]] - 1];
            let draw_func = SHAPE[stimolo.stim[i][index[2]] - 1];
            draw_func(context, i * 200 + 100, 300, size, color);

            record_entry.push([size, color, draw_func, stimolo.word, stimolo.correct]);
        }
        record.push(record_entry);

        context.font = "60pt Arial";
        context.fillText(stimolo.word, 650, 325);

        // Draw the right part: previous trials
        draw_right(context, record, mos = 'main', condition = 'LOT_listener');
    },
    canvas_size: [800, 1300],
    choices: ['j', 'k', 'l'],
    data: {
        task: 'listener_LOT_only',
    },
    on_finish: function(data){
        // Cannot add together correct_response and correct, because correct_response needs to be there in order for correct to be added
        jsPsych.data.get().addToLast({correct_response: filterByWord(return_stimulus(current_stimulus), jsPsych.timelineVariable('letter'))[trial_id].correct_response});
        jsPsych.data.get().addToLast({correct: jsPsych.pluginAPI.compareKeys(data.response, data.correct_response)});
        jsPsych.data.get().addToLast({randomization: [index, SHAPE[0].name, SHAPE[1].name, SHAPE[2].name, COLOR, SIZE]});
        jsPsych.data.get().addToLast({block_number: block_order_number[current_stimulus]});
        jsPsych.data.get().addToLast({word_used: jsPsych.timelineVariable('letter')});
        jsPsych.data.get().addToLast({label: labeling_data(mixed_or_control = "control", block = data.block_number, correctness = data.correct, trial_number = trial_id, p_or_q = data.word_used)});
    }
}

var feedback_trial = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: function() {
    var last_trial_correct = jsPsych.data.get().last(1).values()[0].correct;
    if(last_trial_correct) {
      return "<p><b>Correct!</b></p>You returned the object that the other participant wanted you to return.</p><p>Press any key to continue</p>";
    } else {
      return "<p><b>Incorrect.</b></p>You can see the right answer underlined in the record on the right part of the screen.</p><p>Press any key to continue</p>";
    }
  },
  trial_duration: 5000,
}

// Look at complete record of previous trials: critical version
let show_ask_for_p = {
    type: jsPsychCanvasKeyboardResponse,
    stimulus: (canvas) => {

        let context = canvas.getContext('2d');
        // Draw the left part: text
        context.font = "20pt Arial";
        let text = 
        `You have reached the end of this block.\nPlease carefully consider the meaning of\nthe word associated with p. You can\nlook at the record of the trials in the right\npart of the screen and take as long as\nyou need.\n
When you are ready, press the space bar\nand you will stop seeing the record of the\ntrials and be allowed to type the meaning\nof the concept associated with p.`;
        let lines = text.split('\n');
        // Define the starting y-coordinate for the text
        let y = 180;
        // Draw each line of text, then increment y value for line spacing
        for (let i = 0; i < lines.length; i++) {
            context.fillText(lines[i], 200, y);
            y += 30;
        }
        
        // Draw the right part: previous trials
        draw_right(context, record, mos = 'show', condition = 'listener')
    },
    canvas_size: [800, 1300],
    choices: [' '],
}

let show_ask_for_q = {
    type: jsPsychCanvasKeyboardResponse,
    stimulus: (canvas) => {

        let context = canvas.getContext('2d');
        // Draw the left part: text
        context.font = "20pt Arial";
        let text = 
        `Now, please consider the meaning of\nthe word associated with q. You can\nlook at the record of the trials in the right\npart of the screen and take as long as\nyou need.\n
When you are ready, press the space bar\nand you will stop seeing the record of the\ntrials and be allowed to type the meaning\nof the concept associated with q.`;
        let lines = text.split('\n');
        // Define the starting y-coordinate for the text
        let y = 180;
        // Draw each line of text, then increment y value for line spacing
        for (let i = 0; i < lines.length; i++) {
            context.fillText(lines[i], 200, y);
            y += 30;
        }
        
        // Draw the right part: previous trials
        draw_right(context, record, mos = 'show', condition = 'listener')
    },
    canvas_size: [800, 1300],
    choices: [' '],
}

// Look at complete record of previous trials: control version
let show_ask_for_a_concept = {
    type: jsPsychCanvasKeyboardResponse,
    stimulus: (canvas) => {
        
        let context = canvas.getContext('2d');
        // Draw the left part: text
        context.font = "20pt Arial";
        let text = 
        `You have reached the end of this block.\nPlease carefully consider the meaning of\nthe word associated with ${jsPsych.timelineVariable('letter')}. You can\nlook at the record of the trials in the right\npart of the screen and take as long as\nyou need.

When you are ready, press the space bar\nand you will stop seeing the record of the\ntrials and be allowed to type the meaning\nof the concept that you have been learning.`;
        // Break the text into multiple lines
        let lines = text.split('\n');
        // Define the starting y-coordinate for the text
        let y = 180;
        // Draw each line of text, then increment y value for line spacing
        for (let i = 0; i < lines.length; i++) {
            context.fillText(lines[i], 200, y);
            y += 30;
        }
        
        // Draw the right part: previous trials
        draw_right(context, record, mos = 'show', condition = 'LOT_listener');
        trial_id = 0;
        record = [];
    },
    canvas_size: [800, 1300],
    choices: [' '],
}

// Ask for both concepts: critical listener
var ask_for_P = {
  type: jsPsychSurvey,
  pages: [
    [
      {
        type: 'text',
        prompt: "What is the meaning of the word associated with P?", 
        name: 'p_meaning_participants',
        required: true,
      }
    ]
  ],
  button_label_finish: 'Submit',
  required_question_label: "",
  on_finish: function(data){
        jsPsych.data.get().addToLast({right_P: find_right_concept("P")});
    }
}

var ask_for_Q = {
  type: jsPsychSurvey,
  pages: [
    [
      {
        type: 'text',
        prompt: "What is the meaning of the word associated with Q?", 
        name: 'q_meaning_participants', 
        required: true,
      }
    ]
  ],
  button_label_finish: 'Submit',
  required_question_label: "",
  on_finish: function(data){
        jsPsych.data.get().addToLast({right_Q: find_right_concept("Q")});
    }
}

// Ask for learnt concept: control listener
var ask_for_a_concept = {
  type: jsPsychSurvey,
  pages: [
    [
      {
        type: 'text',
        prompt: function() { return `What is the meaning of the word associated with ${jsPsych.timelineVariable('letter')}?`}, 
        name: function() { return `${jsPsych.timelineVariable('letter')}_meaning_participants`}, 
        required: true,
      }, 
    ]
  ],
  button_label_finish: 'Submit',
  required_question_label: "",
  on_finish: function(data){
        jsPsych.data.get().addToLast({right_concept: find_right_concept(jsPsych.timelineVariable('letter'))});
    }
}

// Reset global variable and randomize features
var reset_global_vars = {
    type: jsPsychCallFunction,
    func: function() {
        trial_id = 0;
        record = [];
        // Randomize indexes
        index = jsPsych.randomization.shuffle(index);
        SIZE = jsPsych.randomization.shuffle(SIZE);
        COLOR = jsPsych.randomization.shuffle(COLOR);
        SHAPE = jsPsych.randomization.shuffle(SHAPE);
        // Move to next stimuli for the listener
        current_stimulus++;
    }
}

var last_page = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `<p>You reached the end of the experiment, thank you for participating!</p>`,
    choices: [' '],
    prompt: "<p>You may now press the space bar to end the experiment and then close this window.</p>"
};

// Internal timeline for control listener
var alternate_letter_listener_LOT = {
    timeline: [
        {
            timeline: [block_listener_LOT_only, feedback_trial],
            loop_function: () => {
                trial_id++;
                return trial_id < stimulus_length / 2;
            },
        },
        show_ask_for_a_concept,
        ask_for_a_concept,
    ],
    timeline_variables: [{letter: 'P'}, {letter: 'Q'}],
    randomize_order: true
};

// Control listener timeline
var listener_procedure_LOT_only = {
    timeline: [
        reset_global_vars,
        instructions_listener_LOT_only,
        alternate_letter_listener_LOT,       
    ],
    repetitions: 4,
    // Randomization of block order is done through the block_order array, to improve trackability
    randomize_order: false
};

// Critical listener timeline
var listener_procedure = {
    timeline: [
        reset_global_vars,
        instructions_listener_mixed,
        {
            timeline: [block_listener_mixed, feedback_trial],
            loop_function: () => {
                trial_id++;
                return trial_id < stimulus_length;
            },
        },
        show_ask_for_p,
        ask_for_P,
        show_ask_for_q,
        ask_for_Q,
    ],
    repetitions: 4,
    // Randomization of block order is done through the block_order array, to improve trackability
    randomize_order: false
};

jsPsych.run([
    welcome,
    refuse_mobile_users,
    enter_fullscreen,
    instructions_speaker,
    {
        timeline: [block_speaker],
        loop_function: () => {
            trial_id++;
            return trial_id < stimulus_speaker.length;
        }
    },
    show_end_speaker,
    // 1/4 of participants will have the LOT only listener blocks and thus be in the control group
    (jsPsych.randomization.shuffle([listener_procedure, listener_procedure, listener_procedure, listener_procedure_LOT_only]))[0],
    last_page,
]);
</script>
</html>
